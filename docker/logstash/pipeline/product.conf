input {

    stdin {
    }

	jdbc {
      # 驱动
      jdbc_driver_library => "/usr/share/logstash/mysql-connector-java.jar"
      # 驱动类名
      jdbc_driver_class => "com.mysql.jdbc.Driver"
      # mysql 数据库链接,shop为数据库名
      jdbc_connection_string => "jdbc:mysql://sg-mysql:3306/es_db?characterEncoding=UTF-8&useSSL=false"
      # 用户名和密码
      jdbc_user => "root"
      jdbc_password => "root"
      jdbc_paging_enabled => "true"
      #jdbc_page_size => "50000"
	  #parameters => {"number" => "0"}
	  # 是否开启记录上次追踪的结果，也就是上次更新的时间，这个会记录到 last_run_metadata_path 的文件
      use_column_value => true
      # 用来控制增量更新的字段，一般是自增id或者创建、更新时间，注意这里要采用sql语句中select采用的字段别名
      tracking_column => "unix_ts_in_secs_md_product"
      # tracking_column 对应字段的类型
      tracking_column_type => "numeric"
	  # 是否将字段名转换为小写，默认true（如果有数据序列化、反序列化需求，建议改为false）；
      lowercase_column_names => false
	  # Value can be any of: fatal,error,warn,info,debug，默认info；
	  sql_log_level => warn
      # 设置监听间隔  各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新
      schedule => "* * * * *"
      statement => "SELECT * ,UNIX_TIMESTAMP(update_time) AS unix_ts_in_secs_md_product FROM md_product WHERE (UNIX_TIMESTAMP(update_time) > :sql_last_value AND update_time < NOW()) ORDER BY update_time ASC"
      # 索引类型
      type => "product"
    }

	jdbc {
      # 驱动
      jdbc_driver_library => "/usr/share/logstash/mysql-connector-java.jar"
      # 驱动类名
      jdbc_driver_class => "com.mysql.jdbc.Driver"
      # mysql 数据库链接,shop为数据库名
      jdbc_connection_string => "jdbc:mysql://sg-mysql:3306/es_db?characterEncoding=UTF-8&useSSL=false"
      # 用户名和密码
      jdbc_user => "root"
      jdbc_password => "root"
      jdbc_paging_enabled => "true"
      #jdbc_page_size => "50000"
	  #parameters => {"number" => "0"}
	  # 是否开启记录上次追踪的结果，也就是上次更新的时间，这个会记录到 last_run_metadata_path 的文件
      use_column_value => true
      # 用来控制增量更新的字段，一般是自增id或者创建、更新时间，注意这里要采用sql语句中select采用的字段别名
      tracking_column => "unix_ts_in_secs_md_category"
      # tracking_column 对应字段的类型
      tracking_column_type => "numeric"
	  # 是否将字段名转换为小写，默认true（如果有数据序列化、反序列化需求，建议改为false）；
      lowercase_column_names => false
	  # Value can be any of: fatal,error,warn,info,debug，默认info；
	  sql_log_level => warn
      # 设置监听间隔  各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新
      schedule => "* * * * *"
      statement => "SELECT * ,UNIX_TIMESTAMP(update_time) AS unix_ts_in_secs_md_category FROM md_category WHERE (UNIX_TIMESTAMP(update_time) > :sql_last_value AND update_time < NOW()) ORDER BY update_time ASC"
      # 索引类型
      type => "category"
    }
}

filter {
  if [type]=="category" {
	  mutate {
			add_field => { "product_join_field" => "category" }
	  }
	}

	if [type]=="product" {
	  mutate {
			add_field => {"[product_join_field][name]" => "product"}

			#cate_id 子表的父id
			add_field => {"[product_join_field][parent]" => "%{cate_id}"}
	  }
	}

}

output {

	if[type] == "category" {
		elasticsearch {
			hosts => ["es01:9200"]
               user => "elastic"
               password => "sangang"
			index => "md_product"
			document_type => "_doc"
			document_id => "%{id}"
		}
    }

    if[type] == "product" {
		elasticsearch {
			hosts => ["es01:9200"]
               user => "elastic"
               password => "sangang"
			index => "md_product"
			document_type => "_doc"
			document_id => "%{id}"
			routing => "%{cate_id}"
		}
	}

    stdout {
        codec => json_lines
    }

}


