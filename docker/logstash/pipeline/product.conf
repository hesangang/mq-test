input {

    stdin {
    }

	jdbc {
      # 驱动
      jdbc_driver_library => "/usr/share/logstash/mysql-connector-java.jar"
      # 驱动类名
      jdbc_driver_class => "com.mysql.jdbc.Driver"
      # mysql 数据库链接,shop为数据库名
      jdbc_connection_string => "jdbc:mysql://sg-mysql8:3306/es_db?characterEncoding=UTF-8&useSSL=false"
      # 用户名和密码
      jdbc_user => "root"
      jdbc_password => "root"
      jdbc_paging_enabled => "true"
      #jdbc_page_size => "50000"
	  #parameters => {"number" => "0"}
	  # 是否开启记录上次追踪的结果，也就是上次更新的时间，这个会记录到 last_run_metadata_path 的文件
      use_column_value => true
      # 用来控制增量更新的字段，一般是自增id或者创建、更新时间，注意这里要采用sql语句中select采用的字段别名
      tracking_column => "unix_ts_in_secs_md_product"
      # tracking_column 对应字段的类型
      tracking_column_type => "numeric"
	  # 是否将字段名转换为小写，默认true（如果有数据序列化、反序列化需求，建议改为false）；
      lowercase_column_names => false
	  # Value can be any of: fatal,error,warn,info,debug，默认info；
	  sql_log_level => warn
      # 设置监听间隔  各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新
      schedule => "* * * * *"
      statement => "SELECT id, product_code, cate_id, cate_name, brand_code, brand_name, product_type, supplier_code, product_name, name_initials, mkt_price, purchasing_price, price, temp_price, price_unit, weight, img, stock_amount, sale_amount, review_count, review_valid_count, review_average, insale_status, favor_status, audit_status,date_format(sale_time,'%Y-%m-%d %H:%i:%s') as sale_time, intro, alert_amount, usable_amount, no_stock, maker, sort, quota_amount, bissness_type, purchaser_code,date_format(un_sale_time,'%Y-%m-%d %H:%i:%s') as un_sale_time, video_path, video_banner, create_user, date_format(create_time,'%Y-%m-%d %H:%i:%s') as create_time, update_user, date_format(update_time,'%Y-%m-%d %H:%i:%s') as update_time, is_del ,UNIX_TIMESTAMP(update_time) AS unix_ts_in_secs_md_product FROM md_product WHERE (UNIX_TIMESTAMP(update_time) > :sql_last_value AND update_time < NOW()) ORDER BY update_time ASC"
      # 索引类型
      type => "product"
    }

	jdbc {
      # 驱动
      jdbc_driver_library => "/usr/share/logstash/mysql-connector-java.jar"
      # 驱动类名
      jdbc_driver_class => "com.mysql.jdbc.Driver"
      # mysql 数据库链接,shop为数据库名
      jdbc_connection_string => "jdbc:mysql://sg-mysql:3306/es_db?characterEncoding=UTF-8&useSSL=false"
      # 用户名和密码
      jdbc_user => "root"
      jdbc_password => "root"
      jdbc_paging_enabled => "true"
      #jdbc_page_size => "50000"
	  #parameters => {"number" => "0"}
	  # 是否开启记录上次追踪的结果，也就是上次更新的时间，这个会记录到 last_run_metadata_path 的文件
      use_column_value => true
      # 用来控制增量更新的字段，一般是自增id或者创建、更新时间，注意这里要采用sql语句中select采用的字段别名
      tracking_column => "unix_ts_in_secs_md_category"
      # tracking_column 对应字段的类型
      tracking_column_type => "numeric"
	  # 是否将字段名转换为小写，默认true（如果有数据序列化、反序列化需求，建议改为false）；
      lowercase_column_names => false
	  # Value can be any of: fatal,error,warn,info,debug，默认info；
	  sql_log_level => warn
      # 设置监听间隔  各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新
      schedule => "* * * * *"
      statement => "SELECT id, parent_id, category_name, category_code, category_type, status, sort, update_user, date_format(update_time,'%Y-%m-%d %H:%i:%s') as update_time, create_user, date_format(create_time,'%Y-%m-%d %H:%i:%s') as create_time, is_del,UNIX_TIMESTAMP(update_time) AS unix_ts_in_secs_md_category FROM md_category WHERE (UNIX_TIMESTAMP(update_time) > :sql_last_value AND update_time < NOW()) ORDER BY update_time ASC"
      # 索引类型
      type => "category"
    }
}

filter {
  date {
    match        => [ "timestamp" , "dd/MMM/YYYY:HH:mm:ss Z", "UNIX", "yyyy-MM-dd HH:mm:ss", "dd-MMM-yyyy HH:mm:ss" ]
  }
  mutate {
    copy => { "id" => "[@metadata][_id]"}
    remove_field => ["@timestamp", "@version", "unix_ts_in_secs"]
  }
}

filter {
  if [type]=="category" {
	  mutate {
			add_field => { "product_join_field" => "category" }
	  }
	}

	if [type]=="product" {
	  mutate {
			add_field => {"[product_join_field][name]" => "product"}

			#cate_id 子表的父id
			add_field => {"[product_join_field][parent]" => "%{cate_id}"}
	  }
	}

}

output {

	if[type] == "category" {
		elasticsearch {
			hosts => ["es01:9200"]
               user => "elastic"
               password => "sangang"
			index => "md_product"
			document_type => "_doc"
			document_id => "%{id}"
		}
    }

    if[type] == "product" {
		elasticsearch {
			hosts => ["es01:9200"]
               user => "elastic"
               password => "sangang"
			index => "md_product"
			document_type => "_doc"
			document_id => "%{id}"
			routing => "%{cate_id}"
		}
	}

    stdout {
        codec => json_lines
    }

}


